{
  "Authentifizierung vs. Autorisierung": "`Authentifizierung` ist der Prozess, bei dem die Identität eines Benutzers überprüft wird.\n`Autorisierung` ist der Prozess, bei dem überprüft wird, ob ein Benutzer auf bestimmte Ressourcen zugreifen darf.",
  "Code Smells": "Code Smells sind Anzeichen in deinem Code, die auf tiefer liegende Probleme hinweisen können.\nBeispiele hierfür sind überlange Funktionen, verschachtelte Schleifen, globale Variablen und duplizierter Code. Durch das Identifizieren dieser \"Code Smells\" kannst du gezielt Verbesserungen vornehmen.",
  "Guard Clause": "Strenggenommen ist die Guard Clause eine Operations-Logik, welche die Methode nach IOSP auch zu einer Operations-Logik, statt einer Integration-Logik macht.",
  "Kopplung und Kohäsion": "- `Kopplung` ist die Abhängigkeit zwischen zwei oder mehr Modulen oder Komponenten.\nSie beschreibt, wie stark zwei oder mehr Module oder Komponenten voneinander abhängig sind.\n- `Kohäsion` ist die Zusammengehörigkeit von Funktionalitäten innerhalb eines Moduls, Klasse oder einer Komponente.\nSie beschreibt, wie stark die Funktionalität innerhalb eines Moduls, Klasse oder einer Komponente zusammenhängt.",
  "Model Driven Development vs. Domain Driven Design": "- **Model Driven Development (MDE)** konzentriert sich auf die Modellierung von Software.\nEs versucht, durch den Einsatz von Modellen auf höheren Abstraktionsebenen den Softwareentwicklungsprozess zu verbessern und zu automatisieren. \nDiese Modelle werden oft direkt in Code übersetzt (Code-Generierung).\nIn MDE beschreibt man die Objekte (Entitäten) und ihre Beziehungen oft in Form von Modellen, z.B. UML-Diagrammen (Unified Modeling Language). \nDie Idee ist, dass man von diesen Modellen ausgeht und sie schrittweise verfeinert, bis sie entweder automatisch in lauffähigen Code umgewandelt werden oder als Grundlage für die Implementierung dienen.\nDie Interaktionen zwischen den Objekten können in den Modellen beschrieben werden und dann in eine Implementierung überführt werden, in der die verschiedenen Objekten über APIs, Methodenaufrufe oder Events miteinander interagieren.\n- **Domain Driven Design (DDE)** hingegen konzentriert sich auf die Modellierung von Domänenwissen und die Implementierung von Software, die dieses Domänenwissen umsetzt.\nDabei wird eine starke Trennung zwischen der Domäne und der technischen Implementierung vorgenommen.\nDas Domänenmodell steht dabei im Mittelpunkt und wird durch die Implementierung umgesetzt.\nDie Domänenobjekte spielen eine zentrale Rolle und werden durch die Geschäftslogik und nicht durch technische Aspekte bestimmt.\nIn DDD werden Entitäten oft durch Begriffe aus der „Ubiquitous Language“ (eine gemeinsame Sprache zwischen Entwicklern und Fachexperten) beschrieben, sodass das Modell die Realität des Geschäfts widerspiegelt.\nIn DDD wird die Interaktion zwischen den Entitäten durch bestimmte Muster wie Aggregate (Sammlung verwandter Entitäten), Repositories (Zugriff auf gespeicherte Entitäten) und Services strukturiert. Diese Interaktionen spiegeln die realen Geschäftsprozesse wider, die die Entitäten repräsentieren.",
  "Operation vs. Integration": "Eine **Operations-Logik** enthält Bedingungen, Schleifen, etc., die die Geschäftsregeln implementieren.\nAuch API-Aufrufe oder andere I/O-Operationen gehören zur Operations-Logik.\nEine **Integration-Logik** enthält Code, der andere Code verwendet, um die Operations-Logik zu implementieren.\nEine **Hybrid-Logik** enthält sowohl Operations- als auch Integrationslogik.",
  "Polymorphismus: Verhalten vs. Daten": "Oftmals wird Polymporphismus verwendet, um einer abgeleiteten Klasse zusätzliche Daten hinzuzufügen.\nDas ist jedoch nicht der Sinn von Polymorphismus.\nPolymorphismus handelt von Verhalten, nicht von Daten.\nKurz: Polymorphismus bedeutet, das abgeleitete Klassen sich nur in ihrem Verhalten unterscheiden, nicht in ihren Daten.\nWenn Daten hinzu gefügt werden sollen, ist es besser das [Pattern Komposition](./4.designpatterns/structural#composite) zu verwenden.",
  "Refactoring vs. Refaktorisierung": "- **Refactoring** ist der Prozess, bei dem der Code verbessert wird, ohne das Verhalten zu ändern.\n- **Refaktorisierung** ist die Tätigkeit, die während des Refactorings durchgeführt wird.",
  "Schein-Konstanten": "Objekte oder Array-Inhalte sind immer veränderbar, auch wenn sie mit `final` deklariert werden.\nNur die Zuweisung der Variable ist konstant, nicht der Wert.\nIn Java gibt es keine Möglichkeit, den Inhalt eines Objekts oder Arrays zu sperren.\nAlternativen sind die Software Prinzipien [Tell, don't ask](./2.principles/principles#tda-ie) und [Information Hiding](./2.principles/principles#ih-e).",
  "Senior-Entwickler vs. Junior-Entwickler": "Beim Verständnis von Code sollte es keine Rolle spielen, ob der Entwickler ein Senior- oder Junior-Entwickler ist.\nDie große Erfahrung bei Senior-Entwicklern kann dazu führen, dass sie unnötig komplexen Code schreiben, der nicht nur für Junior-Entwickler schwer zu verstehen ist.\nEs ist daher wichtig, dass Code so geschrieben wird, dass er von jedem Entwickler verstanden werden kann.\nBeide Seiten sollen von der Zusammenarbeit profitieren und voneinander lernen.\nJunior-Entwickler sollen sich nicht scheuen, Fragen zu stellen, wenn sie etwas nicht verstehen.\nDagegen sollen Senior-Entwickler offen für Fragen sein und bereit sein, ihr Wissen zu teilen, denn auch sie waren einmal Junior-Entwickler.\nDadurch können Junior-Entwickler viel lernen und werden so schneller zu wertvollen Teammitgliedern."
}